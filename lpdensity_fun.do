********************************************************************************
* LPDENSITY STATA PACKAGE -- lpdensity mata function
* Authors: Matias D. Cattaneo, Michael Jansson, Xinwei Ma
********************************************************************************
*!version 0.1  07Jul2017

** do lpdensity_fn.ado

capture mata mata drop lpdensity_fn()

mata
real matrix lpdensity_fn(real colvector x,
                         real colvector grid,
						 real colvector bw,
						 real scalar p, real scalar q, real scalar v,
						 string scalar kernel,
						 real colvector cweights,
						 real colvector pweights,
						 real scalar scale,
						 real scalar level){
						 
ii = order(x, 1)
x = x[ii, 1]; cweights = cweights[ii, 1]; pweights = pweights[ii, 1]
	
n  = length(x)
ng = length(grid)

Fn = runningsum(cweights :* pweights) :/ sum(cweights :* pweights)

Result = J(ng, 10, .)
	
weights_normal = cweights :* pweights :/ sum(cweights :* pweights) :* n
cweights       = cweights :/ sum(cweights) :* n
pweights       = pweights :/ sum(pweights) :* n

// loop over evaluation points
for (j=1; j<=ng; j++) {
    Result[j, 10] = j
	Result[j, 1] = grid[j]
	
	index_temp = abs(x :- grid[j]) :<= bw[j]
	Result[j, 2] = bw[j]
	Result[j, 3] = sum(index_temp)
	if (Result[j, 3] < p + 1) {
	continue
	}
	
	// LHS and RHS variables
	Y_temp    = select(Fn, index_temp)
	Xh_temp   = select(x :- grid[j], index_temp) :/ bw[j]
	
	// weights
	if (kernel == "triangular") {
		Kh_temp = (1 :- abs(Xh_temp)) :/ bw[j]
	} 
	if (kernel == "uniform") {
		Kh_temp = 0.5 :/ bw[j]
	} 
	if (kernel == "epanechnikov") {
		Kh_temp = 0.75 :* (1 :- Xh_temp:^2) :/ bw[j]
	}
	Kh_temp = select(pweights, index_temp) :* Kh_temp
	
	Xh_p_temp = J(Result[j, 3], p+1, .)
	XhKh_temp = Xh_p_temp
	for (jj=1; jj<=p+1; jj++) {
		Xh_p_temp[., jj] = Xh_temp:^(jj-1)
		XhKh_temp[., jj] = Xh_p_temp[., jj] :* Kh_temp
	}
	XhKhXh_inv = invsym(cross(Xh_p_temp, Kh_temp, Xh_p_temp) :/ n)
	
	// point estimate
	Result[j, 4] = factorial(v) :* (XhKhXh_inv * cross(Xh_p_temp, Kh_temp, Y_temp))[v+1] :/ bw[j]:^v :/ n
	
	// standard error estimate
	F_XhKh_temp = cross(Y_temp, Kh_temp, Xh_p_temp) :/ n
	G = XhKh_temp[Result[j, 3]..1, .]
	
	for (jj=1; jj<=p+1; jj++) {
		G[., jj] = runningsum(G[., jj]) :/ n :- F_XhKh_temp[jj]
	}
	// upper diagonal matrix
	G = cross(G, select(weights_normal, index_temp):^2, G) :/ n

	index_temp_1 = (x :- grid[j]) :< (-1 :* bw[j])
	index_temp_2 = (x :- grid[j]) :> (      bw[j])

	G1 = cross(1 :- Y_temp, Kh_temp, Xh_p_temp) :/ n
	G1 = cross(G1, G1) :* sum(select(weights_normal, index_temp_1):^2) :/ n
	G2 = cross(0 :- Y_temp, Kh_temp, Xh_p_temp) :/ n
	G2 = cross(G2, G2) :* sum(select(weights_normal, index_temp_2):^2) :/ n

	V = XhKhXh_inv * (G + G1 + G2) * XhKhXh_inv

	Result[j, 6] = factorial(v) * sqrt( V[v+1,v+1] / (n * bw[j]^(2*v)) )
		
	// robust CI
	if (q > p) {
		if (Result[j, 3] < q + 1) {
			continue
		}
		Xh_q_temp = J(Result[j, 3], q+1, .)
		XhKh_temp = Xh_q_temp
		for (jj=1; jj<=q+1; jj++) {
			Xh_q_temp[., jj] = Xh_temp:^(jj-1)
			XhKh_temp[., jj] = Xh_q_temp[., jj] :* Kh_temp
		}
		XhKhXh_inv = invsym(cross(Xh_q_temp, Kh_temp, Xh_q_temp) :/ n)

		// point estimate
		Result[j, 5] = factorial(v) :* (XhKhXh_inv * cross(Xh_q_temp, Kh_temp, Y_temp))[v+1] :/ bw[j]:^v :/ n

		// standard error estimate
		F_XhKh_temp = cross(Y_temp, Kh_temp, Xh_q_temp) :/ n
		G = XhKh_temp[Result[j, 3]..1, .]
		for (jj=1; jj<=q+1; jj++) {
			G[., jj] = runningsum(G[., jj]) :/ n :- F_XhKh_temp[jj]
		}
		// upper diagonal matrix
		G = cross(G, select(weights_normal, index_temp):^2, G) :/ n
		index_temp_1 = (x :- grid[j]) :< (-1 :* bw[j])
		index_temp_2 = (x :- grid[j]) :> (      bw[j])

		G1 = cross(1 :- Y_temp, Kh_temp, Xh_q_temp) :/ n
		G1 = cross(G1, G1) :* sum(select(weights_normal, index_temp_1):^2) :/ n
		G2 = cross(0 :- Y_temp, Kh_temp, Xh_q_temp) :/ n
		G2 = cross(G2, G2) :* sum(select(weights_normal, index_temp_2):^2) :/ n
		
		V = XhKhXh_inv * (G + G1 + G2) * XhKhXh_inv

		Result[j, 7] = factorial(v) * sqrt( V[v+1,v+1] / (n * bw[j]^(2*v)) )
	}
		

}
	
Result[., 4..7] = Result[., 4..7] :* scale
	
if (q > p) {
	Result[., 8] = Result[., 5] - invnormal(1-level/2) * Result[., 7]
	Result[., 9] = Result[., 5] + invnormal(1-level/2) * Result[., 7]
}
if (q == p) {
	Result[., 8] = Result[., 4] - invnormal(1-level/2) * Result[., 6]
	Result[., 9] = Result[., 4] + invnormal(1-level/2) * Result[., 6]
}

return(Result)
	
}
mata mosave lpdensity_fn(), replace
end

********************************************************************************
* Normal DGPs
********************************************************************************
capture mata mata drop lpdensity_norm_dgps()

mata
real scalar lpdensity_normDgp(real scalar y, real scalar v, real scalar mu, real scalar sigma){

x = (y - mu) / sigma // normalized evaluation point

if (v == 0 ) out = normal(x) // the cdf

if (v > 0) {
	// compute hermite polynomials
	if (v == 1) H = 1
	if (v == 2) H = x
	if (v > 2) {
		temp = J(v, 1, .)
		temp[1] = 1; temp[2] = x
		for (j=3; j<=v; j++) temp[j] = x * temp[j-1] - (j-2) * temp[j-2]
		H = temp[v]
	}
	// get the sign correct
	H = H * (-1)^(v + 1)	
	// get the scaling correct
	out = H * normalden(x) / sigma^v
}

return(out)

}
mata mosave lpdensity_normDgp(), replace
end

********************************************************************************
* empirical quantile
********************************************************************************
capture mata mata drop lpdensity_quantile()

mata
real scalar lpdensity_quantile(real colvector x, real scalar p){

x = sort(x, 1)
n = length(x)
q = ceil(p * n)
if (q < 1) q = 1
if (q > n) q = n
out = x[q]

return(out)

}
mata mosave lpdensity_quantile(), replace
end

********************************************************************************
* S matrix generation
********************************************************************************
capture mata mata drop lpdensity_Sgen()

mata
real matrix lpdensity_Sgen(real scalar p, string scalar kernel){

if (kernel == "uniform") {
	out =  (1,0,0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909\ 
			0,0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0\ 
			0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769\ 
			0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0\ 
			0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667\ 
			0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0\ 
			0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647\ 
			0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0\ 
			0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684\ 
			0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0\ 
			0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476) 
}
if (kernel == "triangular") {
	out =  (1,0,0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831\ 
			0,0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0\ 
			0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887\ 
			0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0\ 
			0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318\ 
			0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0\ 
			0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977\ 
			0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0\ 
			0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991\ 
			0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0\ 
			0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433)
} 
if (kernel == "epanechnikov") {
	out =  (1,0,0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021\ 
			0,0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0\ 
			0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154\ 
			0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0\ 
			0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529\ 
			0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0\ 
			0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443\ 
			0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0\ 
			0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812\ 
			0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0\ 
			0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236)
}
return(out[1..(p+1), 1..(p+1)])

}
mata mosave lpdensity_Sgen(), replace
end

********************************************************************************
* T matrix generation
********************************************************************************
capture mata mata drop lpdensity_Tgen()

mata
real matrix lpdensity_Tgen(real scalar p, string scalar kernel){

if (kernel == "uniform") {
	out =  (0.5,0,0.166666666666667,0,0.1,0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455\ 
			0,0.166666666666667,0,0.1,0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0\ 
			0.166666666666667,0,0.1,0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385\ 
			0,0.1,0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0\ 
			0.1,0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333\ 
			0,0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0\ 
			0.0714285714285714,0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0,0.0294117647058824\ 
			0,0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0,0.0294117647058824,0\ 
			0.0555555555555556,0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0,0.0294117647058824,0,0.0263157894736842\ 
			0,0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0,0.0294117647058824,0,0.0263157894736842,0\ 
			0.0454545454545455,0,0.0384615384615385,0,0.0333333333333333,0,0.0294117647058824,0,0.0263157894736842,0,0.0238095238095238) 
}
if (kernel == "triangular") {
	out =  (0.666666666666667,0,0.0666666666666667,0,0.019047619047619,0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814\ 
			0,0.0666666666666667,0,0.019047619047619,0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0\ 
			0.0666666666666667,0,0.019047619047619,0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681\ 
			0,0.019047619047619,0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0\ 
			0.019047619047619,0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244\ 
			0,0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0\ 
			0.00793650347516803,0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0,0.000687994496086965\ 
			0,0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0,0.000687994496086965,0\ 
			0.00404040423366886,0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0,0.000687994496086965,0,0.00050125313283208\ 
			0,0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0,0.000687994496086965,0,0.00050125313283208,0\ 
			0.00233100231773814,0,0.00146520146655681,0,0.00098039215666244,0,0.000687994496086965,0,0.00050125313283208,0,0.000376435159043855)
} 
if (kernel == "epanechnikov") {
	out =  (0.6,0,0.0857142857142857,0,0.0285714285714286,0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042\ 
			0,0.0857142857142857,0,0.0285714285714286,0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0\ 
			0.0857142857142857,0,0.0285714285714286,0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683\ 
			0,0.0285714285714286,0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0\ 
			0.0285714285714286,0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889\ 
			0,0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0\ 
			0.012987012987013,0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0,0.00132684652808492\ 
			0,0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0,0.00132684652808492,0\ 
			0.00699300699300699,0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0,0.00132684652808492,0,0.0009807126511932\ 
			0,0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0,0.00132684652808492,0,0.0009807126511932,0\ 
			0.0041958041958042,0,0.00271493212669683,0,0.00185758513931889,0,0.00132684652808492,0,0.0009807126511932,0,0.000745341614906832)
}
return(out[1..(p+1), 1..(p+1)])

}
mata mosave lpdensity_Tgen(), replace
end

********************************************************************************
* C matrix generation
********************************************************************************
capture mata mata drop lpdensity_Cgen()

mata
real matrix lpdensity_Cgen(real scalar k, real scalar p, string scalar kernel){

if (kernel == "uniform") {
	out =  (1,0,0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0\ 
			0,0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647\ 
			0.333333333333333,0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0\ 
			0,0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684\ 
			0.2,0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0\ 
			0,0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476\ 
			0.142857142857143,0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476,0\ 
			0,0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476,0,0.0434782608695652\ 
			0.111111111111111,0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476,0,0.0434782608695652,0\ 
			0,0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476,0,0.0434782608695652,0,0.04\ 
			0.0909090909090909,0,0.0769230769230769,0,0.0666666666666667,0,0.0588235294117647,0,0.0526315789473684,0,0.0476190476190476,0,0.0434782608695652,0,0.04,0) 
}
if (kernel == "triangular") {
	out =  (1,0,0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0\ 
			0,0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977\ 
			0.166666666666667,0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0\ 
			0,0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991\ 
			0.0666666666666667,0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0\ 
			0,0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433\ 
			0.0357142834836158,0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433,0\ 
			0,0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433,0,0.0036231884057971\ 
			0.0222222223188546,0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433,0,0.0036231884057971,0\ 
			0,0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433,0,0.0036231884057971,0,0.00307692307692308\ 
			0.0151515151448831,0,0.0109890109896887,0,0.00833333333323318,0,0.00653594771243977,0,0.00526315789472991,0,0.00432900432900433,0,0.0036231884057971,0,0.00307692307692308,0)
} 
if (kernel == "epanechnikov") {
	out =  (1,0,0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0\ 
			0,0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443\ 
			0.2,0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0\ 
			0,0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812\ 
			0.0857142857142857,0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0\ 
			0,0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236\ 
			0.0476190476190476,0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236,0\ 
			0,0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236,0,0.00521739130434783\ 
			0.0303030303030303,0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236,0,0.00521739130434783,0\ 
			0,0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236,0,0.00521739130434783,0,0.00444444444444445\ 
			0.020979020979021,0,0.0153846153846154,0,0.0117647058823529,0,0.00928792569659443,0,0.0075187969924812,0,0.0062111801242236,0,0.00521739130434783,0,0.00444444444444445,0)
}
return(out[1..(p+1), k+1])

}
mata mosave lpdensity_Cgen(), replace
end

********************************************************************************
* G matrix generation
********************************************************************************
capture mata mata drop lpdensity_Ggen()

mata
real matrix lpdensity_Ggen(real scalar p, string scalar kernel){

if (kernel == "uniform") {
	out =  (-0.333333333333333,0.166666666666667,-0.133333333333333,0.1,-0.0857142857142857,0.0714285714285714,-0.0634920634920635,0.0555555555555556,-0.0505050505050505,0.0454545454545455,-0.041958041958042\ 
			0.166666666666667,0.0666666666666667,0.0555555555555556,0.0380952380952381,0.0333333333333333,0.0264550264550265,0.0238095238095238,0.0202020202020202,0.0185185185185185,0.0163170163170163,0.0151515151515152\ 
			-0.133333333333333,0.0555555555555556,-0.0476190476190476,0.0333333333333333,-0.0296296296296296,0.0238095238095238,-0.0216450216450216,0.0185185185185185,-0.0170940170940171,0.0151515151515152,-0.0141414141414141\ 
			0.1,0.0380952380952381,0.0333333333333333,0.0222222222222222,0.02,0.0155844155844156,0.0142857142857143,0.011965811965812,0.0111111111111111,0.0096969696969697,0.00909090909090909\ 
			-0.0857142857142857,0.0333333333333333,-0.0296296296296296,0.02,-0.0181818181818182,0.0142857142857143,-0.0131868131868132,0.0111111111111111,-0.0103703703703704,0.00909090909090909,-0.00855614973262032\ 
			0.0714285714285714,0.0264550264550265,0.0238095238095238,0.0155844155844156,0.0142857142857143,0.010989010989011,0.0102040816326531,0.00846560846560847,0.00793650793650794,0.00687547746371276,0.0064935064935065\ 
			-0.0634920634920635,0.0238095238095238,-0.0216450216450217,0.0142857142857143,-0.0131868131868132,0.0102040816326531,-0.00952380952380953,0.00793650793650794,-0.00746965452847806,0.0064935064935065,-0.00615174299384826\ 
			0.0555555555555556,0.0202020202020202,0.0185185185185185,0.011965811965812,0.0111111111111111,0.00846560846560847,0.00793650793650794,0.0065359477124183,0.00617283950617284,0.00531632110579479,0.00505050505050505\ 
			-0.0505050505050505,0.0185185185185185,-0.0170940170940171,0.0111111111111111,-0.0103703703703704,0.00793650793650794,-0.00746965452847806,0.00617283950617284,-0.00584795321637427,0.00505050505050505,-0.00481000481000481\ 
			0.0454545454545455,0.0163170163170163,0.0151515151515152,0.0096969696969697,0.00909090909090909,0.00687547746371276,0.00649350649350649,0.00531632110579479,0.00505050505050505,0.00432900432900433,0.00413223140495868\ 
			-0.041958041958042,0.0151515151515152,-0.0141414141414141,0.00909090909090909,-0.00855614973262032,0.00649350649350649,-0.00615174299384826,0.00505050505050505,-0.00481000481000481,0.00413223140495868,-0.00395256916996048) 
}
if (kernel == "triangular") {
	out =  (-0.233332866779462,0.0833330508905063,-0.0531743640785073,0.0333333960560459,-0.0243382259715177,0.0178568590991684,-0.0140329271889015,0.0111109568092491,-0.00914256712672596,0.00757561833195314,-0.00643232469904509\ 
			0.0833333430031619,0.0206349536543496,0.0138889822607069,0.00747358076709329,0.00555558002800799,0.00376385059786869,0.00297624095083857,0.00224683629513331,0.00185187157177693,0.00148741419069681,0.00126263242255087\ 
			-0.0531747120633688,0.0138889436189969,-0.00992067054772658,0.00555558570938115,-0.00427612357529663,0.00297621392905644,-0.00240733368919841,0.00185187029011056,-0.00155068139981584,0.00126263712216438,-0.00108438068750666\ 
			0.0333333291761154,0.00747354338303244,0.0055555555888295,0.00282828659007681,0.00222222610846186,0.00145548770075321,0.00119047711034882,0.000879119696771778,0.000740741774432789,0.000586005979164481,0.00050505152540861\ 
			-0.0243386235494463,0.00555555541211971,-0.00427609423962765,0.0022222251541454,-0.00178710387992154,0.00119047600313231,-0.000989883016025128,0.000740740651962696,-0.00063180824060111,0.000505050436046404,-0.000439378283083419\ 
			0.0178571428772336,0.0037638288080394,0.00297619046584015,0.00145549115212934,0.00119047780581393,0.000758765013497074,0.000637755044256656,0.000461990375582904,0.000396825380503709,0.000309560314164898,0.000270562752861001\ 
			-0.014033189060362,0.00297619047992443,-0.0024073149074495,0.00119047782568061,-0.000989884403822643,0.000637755064921552,-0.00054271705691498,0.000396825400688911,-0.000344133756729751,0.000270562772022687,-0.000238285106683998\ 
			0.01111111111111,0.00224682724469665,0.00185185185231585,0.000879122147763556,0.000740741756863993,0.000461990319945608,0.000396825372642262,0.000282842182321384,0.000246913581918653,0.000190248347383829,0.000168350168854074\ 
			-0.00914270914122569,0.00185185185168499,-0.00155067155074166,0.000740741756146379,-0.000631809109714714,0.000396825371926143,-0.000344133734564222,0.000246913581232753,-0.00021720969177002,0.000168350168212254,-0.000149908647886651\ 
			0.00757575757574178,0.00148740148756518,0.00126256257569384,0.000586007961071109,0.000505051197433514,0.000309560273844802,0.000270562753630222,0.000190248349061672,0.00016835016904926,0.000128330167831491,0.000114784205611466\ 
			-0.00643245643257991,0.00126256257573434,-0.00108431925428119,0.000505051197475794,-0.000439378889047697,0.000270562753671301,-0.000238285092406906,0.000168350169087952,-0.000149908648550576,0.000114784205647198,-0.000103205972768449)
} 
if (kernel == "epanechnikov") {
	out =  (-0.257142857142857,0.1,-0.0666666666666667,0.0428571428571429,-0.032034632034632,0.0238095238095238,-0.018981018981019,0.0151515151515152,-0.0125874125874126,0.0104895104895105,-0.00896750308515014\ 
			0.1,0.0285714285714286,0.02,0.0112554112554113,0.00857142857142857,0.00592740592740593,0.00476190476190476,0.00363636363636364,0.00303030303030303,0.00245166598107775,0.0020979020979021\ 
			-0.0666666666666667,0.02,-0.0147186147186147,0.00857142857142857,-0.00672660672660673,0.00476190476190476,-0.0039027639027639,0.00303030303030303,-0.00256136020841903,0.0020979020979021,-0.00181428478642101\ 
			0.0428571428571429,0.0112554112554113,0.00857142857142857,0.00459540459540459,0.0036734693877551,0.00246420246420246,0.00204081632653061,0.00152710035062976,0.0012987012987013,0.00103586815661119,0.000899100899100899\ 
			-0.032034632034632,0.00857142857142857,-0.00672660672660672,0.0036734693877551,-0.002997002997003,0.00204081632653061,-0.00171514759750054,0.0012987012987013,-0.00111669548202056,0.000899100899100899,-0.000787094374002821\ 
			0.0238095238095238,0.00592740592740593,0.00476190476190476,0.00246420246420246,0.00204081632653061,0.00133591898297781,0.00113378684807256,0.000833634889362443,0.000721500721500722,0.000568059391588803,0.0004995004995005\ 
			-0.018981018981019,0.00476190476190476,-0.0039027639027639,0.00204081632653061,-0.00171514759750054,0.00113378684807256,-0.000973020787262273,0.000721500721500722,-0.000629917038585769,0.0004995004995005,-0.000442294982994558\ 
			0.0151515151515152,0.00363636363636364,0.00303030303030303,0.00152710035062976,0.0012987012987013,0.000833634889362443,0.000721500721500721,0.000522697117124362,0.000459136822773186,0.000357384796744064,0.000317863954227591\ 
			-0.0125874125874126,0.00303030303030303,-0.00256136020841903,0.0012987012987013,-0.00111669548202056,0.000721500721500721,-0.000629917038585769,0.000459136822773186,-0.000406153724231527,0.000317863954227591,-0.000284353327831589\ 
			0.0104895104895105,0.00245166598107775,0.0020979020979021,0.00103586815661119,0.000899100899100899,0.000568059391588803,0.000499500499500499,0.000357384796744064,0.000317863954227591,0.000244972418885462,0.000220059660619101\ 
			-0.00896750308515014,0.0020979020979021,-0.00181428478642101,0.000899100899100899,-0.000787094374002822,0.000499500499500499,-0.000442294982994558,0.000317863954227591,-0.000284353327831589,0.000220059660619101,-0.000198641937772373)
}
return(out[1..(p+1), 1..(p+1)])

}
mata mosave lpdensity_Ggen(), replace
end

********************************************************************************
* mse-rot bandwidth
********************************************************************************
capture mata mata drop lpdensity_bwROT()

mata
real matrix lpdensity_bwROT(	real colvector x,
					real colvector grid,
					real scalar p, real scalar v,
					string scalar kernel,
					real scalar regularize){
					
n 	= length(x)
ng 	= length(grid)

// estimate a normal reference model
mean_hat = mean(x)
sd_hat   = sqrt(variance(x))

// bias estimate, no rate added
bias_dgp = J(ng, 2, .)
for (j=1; j<=ng; j++) {
	bias_dgp[j, 1] = lpdensity_normDgp(grid[j], p+1, mean_hat, sd_hat) / factorial(p+1) * factorial(v)
	bias_dgp[j, 2] = lpdensity_normDgp(grid[j], p+2, mean_hat, sd_hat) / factorial(p+2) * factorial(v) +
		bias_dgp[j, 1] * lpdensity_normDgp(grid[j], 2, mean_hat, sd_hat) / lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat)
 }
 
S  = lpdensity_Sgen(     p, kernel=kernel)
C1 = lpdensity_Cgen(p+1, p, kernel=kernel)
C2 = lpdensity_Cgen(p+2, p, kernel=kernel)
G  = lpdensity_Ggen(     p, kernel=kernel)
S2 = lpdensity_Tgen(     p, kernel=kernel)

bias_dgp[., 1] = bias_dgp[., 1] :* (invsym(S) * C1)[v+1, .]
bias_dgp[., 2] = bias_dgp[., 2] :* (invsym(S) * C2)[v+1, .]

// variance estimate, sample size added
sd_dgp = J(ng, 1, .)
if (v > 0) {
	for (j=1; j<=ng; j++) {
		sd_dgp[j, 1] = factorial(v) * sqrt(lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat) / n)
	}
	sd_dgp = sd_dgp :* sqrt(abs((invsym(S) * G * invsym(S))[v+1, v+1]))
} 
else {
	for (j=1; j<=ng; j++) {
		sd_dgp[j, 1] = factorial(v) * sqrt(
		lpdensity_normDgp(grid[j], 0, mean_hat, sd_hat) * (1 - lpdensity_normDgp(grid[j], 0, mean_hat, sd_hat)) /
		lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat) / (0.5 * n^2))
	}
	sd_dgp = sd_dgp :* sqrt(abs((invsym(S) * S2 * invsym(S))[v+1, v+1]))
}

// bandwidth
h = J(ng, 1, .)

for (j=1; j<=ng; j++) {

	S = optimize_init()
	optimize_init_evaluator(S, &lpdensity_optFunc())
	optimize_init_params(S, 1e-8)
	optimize_init_argument(S, 1, bias_dgp[j, .])
	optimize_init_argument(S, 2, sd_dgp[j, .])
	optimize_init_argument(S, 3, p)
	optimize_init_argument(S, 4, v)
	optimize_init_argument(S, 5, "mse-rot")
	optimize_init_which(S, "min")
	optimize_init_evaluatortype(S, "gf0")
	optimize_init_tracelevel(S, "none")
	optimize_init_conv_maxiter(S, 20)
	(void) optimize(S)
	h[j] = optimize_result_params(S)
	
	if (regularize == 1) {
		h[j] = max((h[j], sort(abs(x:-grid[j]), 1)[20 + p + 1] + 1e-8))
	}
}


return(h) 

}
mata mosave lpdensity_bwROT(), replace
end

********************************************************************************
* imse-rot bandwidth
********************************************************************************
capture mata mata drop lpdensity_bwIROT()

mata
real scalar lpdensity_bwIROT(real colvector x,
					real colvector grid,
					real scalar p, real scalar v,
					string scalar kernel,
					real scalar regularize){
					
n 	= length(x)
ng 	= length(grid)

// estimate a normal reference model
mean_hat = mean(x)
sd_hat   = sqrt(variance(x))

// bias estimate, no rate added
bias_dgp = J(ng, 2, .)
for (j=1; j<=ng; j++) {
	bias_dgp[j, 1] = lpdensity_normDgp(grid[j], p+1, mean_hat, sd_hat) / factorial(p+1) * factorial(v)
	bias_dgp[j, 2] = lpdensity_normDgp(grid[j], p+2, mean_hat, sd_hat) / factorial(p+2) * factorial(v) +
		bias_dgp[j, 1] * lpdensity_normDgp(grid[j], 2, mean_hat, sd_hat) / lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat)
 }
 
S  = lpdensity_Sgen(     p, kernel=kernel)
C1 = lpdensity_Cgen(p+1, p, kernel=kernel)
C2 = lpdensity_Cgen(p+2, p, kernel=kernel)
G  = lpdensity_Ggen(     p, kernel=kernel)
S2 = lpdensity_Tgen(     p, kernel=kernel)

bias_dgp[., 1] = bias_dgp[., 1] :* (invsym(S) * C1)[v+1, .]
bias_dgp[., 2] = bias_dgp[., 2] :* (invsym(S) * C2)[v+1, .]

// variance estimate, sample size added
sd_dgp = J(ng, 1, .)
if (v > 0) {
	for (j=1; j<=ng; j++) {
		sd_dgp[j, 1] = factorial(v) * sqrt(lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat) / n)
	}
	sd_dgp = sd_dgp :* sqrt(abs((invsym(S) * G * invsym(S))[v+1, v+1]))
} 
else {
	for (j=1; j<=ng; j++) {
		sd_dgp[j, 1] = factorial(v) * sqrt(
		lpdensity_normDgp(grid[j], 0, mean_hat, sd_hat) * (1 - lpdensity_normDgp(grid[j], 0, mean_hat, sd_hat)) /
		lpdensity_normDgp(grid[j], 1, mean_hat, sd_hat) / (0.5 * n^2))
	}
	sd_dgp = sd_dgp :* sqrt(abs((invsym(S) * S2 * invsym(S))[v+1, v+1]))
}

// bandwidth
S = optimize_init()
optimize_init_evaluator(S, &lpdensity_optFunc())
optimize_init_params(S, 1e-8)
optimize_init_argument(S, 1, bias_dgp)
optimize_init_argument(S, 2, sd_dgp)
optimize_init_argument(S, 3, p)
optimize_init_argument(S, 4, v)
optimize_init_argument(S, 5, "imse-rot")
optimize_init_which(S, "min")
optimize_init_evaluatortype(S, "gf0")
optimize_init_tracelevel(S, "none")
optimize_init_conv_maxiter(S, 20)
(void) optimize(S)
h = optimize_result_params(S)

if (regularize == 1) {
	for (j=1; j<=ng; j++) {
		h = max((h, sort(abs(x:-grid[j]), 1)[20 + p + 1] + 1e-8))
	}
}

return(h) 

}
mata mosave lpdensity_bwIROT(), replace
end

********************************************************************************
* mse-dpi bandwidth
********************************************************************************
capture mata mata drop lpdensity_bwMSE()

mata
real matrix lpdensity_bwMSE(	real colvector x,
					real colvector grid,
					real scalar p, real scalar v,
					string scalar kernel,
					real colvector cweights,
					real colvector pweights,
					real scalar regularize){

					
ii = order(x, 1)
x = x[ii, 1]; cweights = cweights[ii, 1]; pweights = pweights[ii, 1]	
				
n  = length(x)
ng = length(grid)
Fn = runningsum(cweights :* pweights) :/ sum(cweights :* pweights)	

weights_normal = cweights :* pweights :/ sum(cweights :* pweights) :* n
cweights       = cweights :/ sum(cweights) :* n
pweights       = pweights :/ sum(pweights) :* n

// obtain preliminary bandwidth for estimating densities
// this is used for constructing preasymptotic matrices
h1  = lpdensity_bwIROT(x, grid, 2, 1, kernel, regularize)

// obtain preliminary bandwidth for estimating F_p+1
// this is used for constructing F_p+1
hp1 = lpdensity_bwIROT(x, grid, p+2, p+1, kernel, regularize)

// obtain preliminary bandwidth for estimating F_p+2
// this is used for constructing F_p+2
hp2 = lpdensity_bwIROT(x, grid, p+3, p+2, kernel, regularize)

dgp_hat = J(ng, 2, .) // Fp+1 and Fp+2 with normalization constants
const_hat = J(ng, 3, .)

h = J(ng, 1, .)

for (j=1; j<=ng; j++) {
	// estimate F_p+2
		
	index_temp = (abs(x :- grid[j]) :<= hp2)
	if (sum(index_temp) < p + 4) {
		continue
	}
	
	X_temp = J(sum(index_temp), p+4, 1)	
	X_temp[., 2] = select(x, index_temp) :- grid[j] // centered

	for (jj=3; jj<=p+4; jj++) { 
		X_temp[., jj] = X_temp[., 2]:^(jj-1)
	}
		
	if (kernel == "triangular")  	K_temp = 1 :- abs(X_temp[., 2] :/ hp2)
	if (kernel == "uniform") 		K_temp = 1
	if (kernel == "epanechnikov") 	K_temp = 1 :- (X_temp[., 2] :/ hp2):^2
	K_temp = select(pweights, index_temp) :* K_temp
	
	Y_temp = select(Fn, index_temp)

	dgp_hat[j, 2] = (invsym(cross(X_temp, K_temp, X_temp)) * cross(X_temp, K_temp, Y_temp))[p+3, 1]

	// estimate F_p+1
    index_temp = (abs(x :- grid[j]) :<= hp1)
	if (sum(index_temp) < p + 3) {
		continue
	}
	
	X_temp = J(sum(index_temp), p+3, 1)
	X_temp[., 2] = select(x, index_temp) :- grid[j] // centered
	for (jj=3; jj<=p+3; jj++) { 
		X_temp[., jj] = X_temp[., 2]:^(jj-1)
	}
	
	if (kernel == "triangular")  	K_temp = 1 :- abs(X_temp[., 2] :/ hp1)
	if (kernel == "uniform") 		K_temp = 1
	if (kernel == "epanechnikov") 	K_temp = 1 :- (X_temp[., 2] :/ hp1):^2
	K_temp = select(pweights, index_temp) :* K_temp

	Y_temp = select(Fn, index_temp)
	
	dgp_hat[j, 1] = (invsym(cross(X_temp, K_temp, X_temp)) * cross(X_temp, K_temp, Y_temp))[p+2, 1]

	// prepare for estimating matrices
    index_temp = (abs(x :- grid[j]) :<= h1)
    X_temp_temp = (select(x, index_temp) :- grid[j]) :/ h1 // centered and scaled
	
	if (kernel == "triangular")  	K_temp = (1 :- abs(X_temp_temp)) :/ h1
	if (kernel == "uniform") 		K_temp = 0.5 / h1
	if (kernel == "epanechnikov") 	K_temp = 0.75 :* (1 :- X_temp_temp:^2) :/ h1
	K_temp = select(pweights, index_temp) :* K_temp

    // estimate Cp matrix
	X_temp = J(sum(index_temp), (2*p+1) - (p+1) + 1, 1)
	for (jj=1; jj<=(2*p+1)-(p+1)+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(p+jj)
	}
	
	C_p_hat = cross(X_temp, K_temp, J(sum(index_temp), 1, 1)) :/ n

	// estimate Cp+1 matrix
	X_temp = J(sum(index_temp), (2*p+2) - (p+2) + 1, 1)
	for (jj=1; jj<=(2*p+2)-(p+2)+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(p+jj+1)
	}
	
	C_p1_hat = cross(X_temp, K_temp, J(sum(index_temp), 1, 1)) :/ n
	
	// estimate S matirx
 	X_temp = J(sum(index_temp), p - 0 + 1, 1)
	XhKh_temp = X_temp
	for (jj=1; jj<=p-0+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(jj-1)
		XhKh_temp[., jj] = X_temp[., jj] :* K_temp
	}

	S_hat = cross(X_temp, K_temp, X_temp) :/ n
	S_hat_inv = invsym(S_hat)
	
	if (v > 0) {

		// estimate G matrix
		Y_temp = select(Fn, index_temp)
		F_XhKh_temp = cross(Y_temp, K_temp, X_temp) :/ n
		
		G = XhKh_temp[sum(index_temp)..1, .]

		for (jj=1; jj<=p+1; jj++) {
			G[., jj] = runningsum(G[., jj]) :/ n :- F_XhKh_temp[jj]
		}

		// upper diagonal matrix
		G = cross(G, select(weights_normal, index_temp):^2, G) :/ n

		index_temp_1 = (x :- grid[j]) :< (-1 :* h1)
		index_temp_2 = (x :- grid[j]) :> (      h1)

		G1 = cross(1 :- Y_temp, K_temp, X_temp) :/ n
		G1 = cross(G1, G1) :* sum(select(weights_normal, index_temp_1):^2) :/ n
		G2 = cross(0 :- Y_temp, K_temp, X_temp) :/ n
		G2 = cross(G2, G2) :* sum(select(weights_normal, index_temp_2):^2) :/ n
		G_hat = G + G1 + G2
    } 
	else {
		
		//estimate T matrix
		G_hat = cross(X_temp, K_temp:^2, X_temp) :/ n
    }

	// now get all constants
    const_hat[j, 1] = factorial(v) * (S_hat_inv * C_p_hat )[v+1]
    const_hat[j, 2] = factorial(v) * (S_hat_inv * C_p1_hat)[v+1]
	
    if (v > 0) {
		const_hat[j, 3] = factorial(v) * sqrt(abs((S_hat_inv * G_hat * S_hat_inv)[v+1,v+1]) / (n * h1))
    } 
	else {
		temp_ii = max((mean(x :<= grid[j]), 1/n))
		const_hat[j, 3] = factorial(v) * sqrt(abs((S_hat_inv * G_hat * S_hat_inv)[v+1,v+1]) / (0.5 * n^2) * 
			h1 * temp_ii * (1 - temp_ii))
    }
	

	// now optimal bandwidth
	S = optimize_init()
	optimize_init_evaluator(S, &lpdensity_optFunc())
	optimize_init_params(S, 1e-8)
	optimize_init_argument(S, 1, dgp_hat[j, .])
	optimize_init_argument(S, 2, const_hat[j, .])
	optimize_init_argument(S, 3, p)
	optimize_init_argument(S, 4, v)
	optimize_init_argument(S, 5, "mse-dpi")
	optimize_init_which(S, "min")
	optimize_init_evaluatortype(S, "gf0")
	optimize_init_tracelevel(S, "none")
	optimize_init_conv_maxiter(S, 20)
	(void) optimize(S)
	h[j] = optimize_result_params(S)
	
	if (regularize == 1) {
		h[j] = max((h[j], sort(abs(x:-grid[j]), 1)[20 + p + 1] + 1e-8))
	}
}

return(h)

}
mata mosave lpdensity_bwMSE(), replace
end

********************************************************************************
* imse-dpi bandwidth
********************************************************************************
capture mata mata drop lpdensity_bwIMSE()

mata
real scalar lpdensity_bwIMSE(real colvector x,
					real colvector grid,
					real scalar p, real scalar v,
					string scalar kernel,
					real colvector cweights,
					real colvector pweights,
					real scalar regularize){

					
ii = order(x, 1)
x = x[ii, 1]; cweights = cweights[ii, 1]; pweights = pweights[ii, 1]	
				
n  = length(x)
ng = length(grid)
Fn = runningsum(cweights :* pweights) :/ sum(cweights :* pweights)	

weights_normal = cweights :* pweights :/ sum(cweights :* pweights) :* n
cweights       = cweights :/ sum(cweights) :* n
pweights       = pweights :/ sum(pweights) :* n

// obtain preliminary bandwidth for estimating densities
// this is used for constructing preasymptotic matrices
h1  = lpdensity_bwIROT(x, grid, 2, 1, kernel, regularize)

// obtain preliminary bandwidth for estimating F_p+1
// this is used for constructing F_p+1
hp1 = lpdensity_bwIROT(x, grid, p+2, p+1, kernel, regularize)

// obtain preliminary bandwidth for estimating F_p+2
// this is used for constructing F_p+2
hp2 = lpdensity_bwIROT(x, grid, p+3, p+2, kernel, regularize)

dgp_hat = J(ng, 2, .) // Fp+1 and Fp+2 with normalization constants
const_hat = J(ng, 3, .)

h = J(ng, 1, .)

for (j=1; j<=ng; j++) {
	// estimate F_p+2
		
	index_temp = (abs(x :- grid[j]) :<= hp2)
	if (sum(index_temp) < p + 4) {
		continue
	}
	
	X_temp = J(sum(index_temp), p+4, 1)	
	X_temp[., 2] = select(x, index_temp) :- grid[j] // centered

	for (jj=3; jj<=p+4; jj++) { 
		X_temp[., jj] = X_temp[., 2]:^(jj-1)
	}
		
	if (kernel == "triangular")  	K_temp = 1 :- abs(X_temp[., 2] :/ hp2)
	if (kernel == "uniform") 		K_temp = 1
	if (kernel == "epanechnikov") 	K_temp = 1 :- (X_temp[., 2] :/ hp2):^2
	K_temp = select(pweights, index_temp) :* K_temp
	
	Y_temp = select(Fn, index_temp)

	dgp_hat[j, 2] = (invsym(cross(X_temp, K_temp, X_temp)) * cross(X_temp, K_temp, Y_temp))[p+3, 1]

	// estimate F_p+1
    index_temp = (abs(x :- grid[j]) :<= hp1)
	if (sum(index_temp) < p + 3) {
		continue
	}
	
	X_temp = J(sum(index_temp), p+3, 1)
	X_temp[., 2] = select(x, index_temp) :- grid[j] // centered
	for (jj=3; jj<=p+3; jj++) { 
		X_temp[., jj] = X_temp[., 2]:^(jj-1)
	}
	
	if (kernel == "triangular")  	K_temp = 1 :- abs(X_temp[., 2] :/ hp1)
	if (kernel == "uniform") 		K_temp = 1
	if (kernel == "epanechnikov") 	K_temp = 1 :- (X_temp[., 2] :/ hp1):^2
	K_temp = select(pweights, index_temp) :* K_temp

	Y_temp = select(Fn, index_temp)
	
	dgp_hat[j, 1] = (invsym(cross(X_temp, K_temp, X_temp)) * cross(X_temp, K_temp, Y_temp))[p+2, 1]

	// prepare for estimating matrices
    index_temp = (abs(x :- grid[j]) :<= h1)
    X_temp_temp = (select(x, index_temp) :- grid[j]) :/ h1 // centered and scaled
	
	if (kernel == "triangular")  	K_temp = (1 :- abs(X_temp_temp)) :/ h1
	if (kernel == "uniform") 		K_temp = 0.5 / h1
	if (kernel == "epanechnikov") 	K_temp = 0.75 :* (1 :- X_temp_temp:^2) :/ h1
	K_temp = select(pweights, index_temp) :* K_temp

    // estimate Cp matrix
	X_temp = J(sum(index_temp), (2*p+1) - (p+1) + 1, 1)
	for (jj=1; jj<=(2*p+1)-(p+1)+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(p+jj)
	}
	
	C_p_hat = cross(X_temp, K_temp, J(sum(index_temp), 1, 1)) :/ n

	// estimate Cp+1 matrix
	X_temp = J(sum(index_temp), (2*p+2) - (p+2) + 1, 1)
	for (jj=1; jj<=(2*p+2)-(p+2)+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(p+jj+1)
	}
	
	C_p1_hat = cross(X_temp, K_temp, J(sum(index_temp), 1, 1)) :/ n
	
	// estimate S matirx
 	X_temp = J(sum(index_temp), p - 0 + 1, 1)
	XhKh_temp = X_temp
	for (jj=1; jj<=p-0+1; jj++) {
		X_temp[., jj] = X_temp_temp:^(jj-1)
		XhKh_temp[., jj] = X_temp[., jj] :* K_temp
	}

	S_hat = cross(X_temp, K_temp, X_temp) :/ n
	S_hat_inv = invsym(S_hat)
	
	if (v > 0) {

		// estimate G matrix
		Y_temp = select(Fn, index_temp)
		F_XhKh_temp = cross(Y_temp, K_temp, X_temp) :/ n
		
		G = XhKh_temp[sum(index_temp)..1, .]

		for (jj=1; jj<=p+1; jj++) {
			G[., jj] = runningsum(G[., jj]) :/ n :- F_XhKh_temp[jj]
		}

		// upper diagonal matrix
		G = cross(G, select(weights_normal, index_temp):^2, G) :/ n

		index_temp_1 = (x :- grid[j]) :< (-1 :* h1)
		index_temp_2 = (x :- grid[j]) :> (      h1)

		G1 = cross(1 :- Y_temp, K_temp, X_temp) :/ n
		G1 = cross(G1, G1) :* sum(select(weights_normal, index_temp_1):^2) :/ n
		G2 = cross(0 :- Y_temp, K_temp, X_temp) :/ n
		G2 = cross(G2, G2) :* sum(select(weights_normal, index_temp_2):^2) :/ n
		G_hat = G + G1 + G2
    } 
	else {
		
		//estimate T matrix
		G_hat = cross(X_temp, K_temp:^2, X_temp) :/ n
    }

	// now get all constants
    const_hat[j, 1] = factorial(v) * (S_hat_inv * C_p_hat )[v+1]
    const_hat[j, 2] = factorial(v) * (S_hat_inv * C_p1_hat)[v+1]
	
    if (v > 0) {
		const_hat[j, 3] = factorial(v) * sqrt(abs((S_hat_inv * G_hat * S_hat_inv)[v+1,v+1]) / (n * h1))
    } 
	else {
		temp_ii = max((mean(x :<= grid[j]), 1/n))
		const_hat[j, 3] = factorial(v) * sqrt(abs((S_hat_inv * G_hat * S_hat_inv)[v+1,v+1]) / (0.5 * n^2) * 
			h1 * temp_ii * (1 - temp_ii))
    }
}

// bandwidth
S = optimize_init()
optimize_init_evaluator(S, &lpdensity_optFunc())
optimize_init_params(S, 1e-8)
optimize_init_argument(S, 1, dgp_hat)
optimize_init_argument(S, 2, const_hat)
optimize_init_argument(S, 3, p)
optimize_init_argument(S, 4, v)
optimize_init_argument(S, 5, "imse-dpi")
optimize_init_which(S, "min")
optimize_init_evaluatortype(S, "gf0")
optimize_init_tracelevel(S, "none")
optimize_init_conv_maxiter(S, 20)
(void) optimize(S)
h = optimize_result_params(S)

if (regularize == 1) {
	for (j=1; j<=ng; j++) {
		h = max((h, sort(abs(x:-grid[j]), 1)[20 + p + 1] + 1e-8))
	}
}

return(h) 

}
mata mosave lpdensity_bwIMSE(), replace
end

********************************************************************************
* optimization criterion function
********************************************************************************
capture mata mata drop lpdensity_optFunc()

mata
void lpdensity_optFunc(todo, h, mat1, mat2, p, v, bwselect, fn, gn, hn) {
	if (bwselect == "imse-dpi") {
		if (v > 0) {
			fn = sum( h^(2*p+2-2*v) :* (mat1[., 1] :* mat2[., 1] :+ h :* mat1[., 2] :* mat2[., 2]):^2 + mat2[., 3]:^2 :/ h^(2*v - 1) )
		} else {
			fn = sum( h^(2*p+2-2*v) :* (mat1[., 1] :* mat2[., 1] :+ h :* mat1[., 2] :* mat2[., 2]):^2 + mat2[., 3]:^2 :/ h )
		}
	}
	else if (bwselect == "imse-rot") {
		if (v > 0) {
			fn = sum( h^(2*p+2-2*v) :* (mat1[., 1] :+ h :* mat1[., 2]):^2 + mat2[., 1]:^2 :/ h^(2*v - 1) )
		} else {
			fn = sum( h^(2*p+2-2*v) :* (mat1[., 1] :+ h :* mat1[., 2]):^2 + mat2[., 1]:^2 :/ h )
		}
	} else if (bwselect == "mse-dpi") {
		if (v > 0) {
			fn = h^(2*p+2-2*v) * (mat1[1] * mat2[1] + h * mat1[2] * mat2[2])^2 + mat2[3]^2 / h^(2*v - 1)
		} else {
			fn = h^(2*p+2-2*v) * (mat1[1] * mat2[1] + h * mat1[2] * mat2[2])^2 + mat2[3]^2 / h
		}
	} else {
		if (v > 0) {
			fn = h^(2*p+2-2*v) * (mat1[1] + h * mat1[2])^2 + mat2[1]^2 / h^(2*v - 1)
		} else {
			fn = h^(2*p+2-2*v) * (mat1[1] + h * mat1[2])^2 + mat2[1]^2 / h
		}
	}
	
}
mata mosave lpdensity_optFunc(), replace
end
